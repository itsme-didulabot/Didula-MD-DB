const { cmd, commands } = require('../lib/command');
const config = require('../settings');
const si = require('systeminformation');
const pdfUrl = "https://i.ibb.co/tC37Q7B/20241220-122443.jpg";
const fs = require('fs');
const path = require('path')

const yts = require('yt-search');
import axios from 'axios';


// YouTube Downloader (YTDL) Scraper
function extractYouTubeID(url) {
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]+)/;
    const match = url.match(regex);
    return match ? match[1] : null;
}

const ytdl = {
   getInfo: async (url) => {
      let idYt = extractYouTubeID(url);
      let { data } = await axios.get(`https://c01-h01.cdnframe.com/api/v4/info/${idYt}`);
      return data; // Return data directly
   },
   
   convert: async (token) => {
      let payload = { "token": token };
      let { data } = await axios.post("https://c01-h01.cdnframe.com/api/v4/convert", payload);
      return data; // Return data directly
   },
   
   download: async (jobId) => {
      let { data } = await axios.get(`https://c01-h01.cdnframe.com/api/v4/status/${jobId}`);
      return data; // Return data directly
   }
};

// Song Command
cmd({
    pattern: "song",
    react: "üéµ",
    desc: "download song",
    category: "download",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q }) => {
    try {
        if (!q) return reply("*‚ùåPlease give me URL or title*");
        const search = await yts(q);
        const deta = search.videos[0];
        const url = deta.url;

        let desc = `
 *üé∂ùó°ùóúùó•ùó¢-ùó†ùóó   ùóîùó®ùóóùóúùó¢-ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùó•üé∂*
|__________________________
| ‚ÑπÔ∏è *title* : *${deta.title}*
| üìã *description* : *${deta.description}*
| üïò *time* : *${deta.timestamp}*
| üìå *ago* : *${deta.ago}*
| üìâ *views* : *${deta.views}*
|__________________________

*¬©·¥ò·¥è·¥°·¥á Ä·¥Ö  ô è …¥…™ Ä·¥è-·¥ç·¥Ö*`;

        await conn.sendMessage(from, { image: { url: deta.thumbnail }, caption: desc }, { quoted: mek });

        // Using YTDL to get download link
        const info = await ytdl.getInfo(url);
        const downloadUrl = info.downloadUrl; // Adjust according to the actual data structure returned

        // Send audio message 
        await conn.sendMessage(from, { audio: { url: downloadUrl }, mimetype: "audio/mpeg", caption: "*¬©·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è …¥…™ Ä·¥è-·¥ç·¥Ö*" }, { quoted: mek });
        await conn.sendMessage(from, { document: { url: downloadUrl }, mimetype: "audio/mpeg", fileName: deta.title + ".mp3", caption: "*¬©·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è …¥…™ Ä·¥è-·¥ç·¥Ö*" }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply(`${e}`);
    }
});

// Video Command
cmd({
    pattern: "video",
    react: "üé•",
    desc: "download video",
    category: "download",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q }) => {
    try {
        if (!q) return reply("‚ùåPlease give me URL or title");
        const search = await yts(q);
        const deta = search.videos[0];
        const url = deta.url;

        let desc = `
*üìΩÔ∏èùó°ùóúùó•ùó¢-ùó†ùóó   ùó©ùóúùóóùóòùó¢-ùóóùó¢ùó™ùó°ùóüùó¢ùóîùóóùóòùó•üìΩÔ∏è*
|__________________________
| ‚ÑπÔ∏è *title* : *${deta.title}*
| üìã *description* : *${deta.description}*
| üïò *time* : *${deta.timestamp}*
| üìå *ago* : *${deta.ago}*
| üìâ *views* : *${deta.views}*
|__________________________

*¬©·¥ò·¥è·¥°·¥á Ä·¥Ö  ô è …¥…™ Ä·¥è-·¥ç·¥Ö*`;

        await conn.sendMessage(from, { image: { url: deta.thumbnail }, caption: desc }, { quoted: mek });

        // Using YTDL to get download link
        const info = await ytdl.getInfo(url);
        const downloadUrl = info.downloadUrl; // Adjust according to the actual data structure returned

        // Send video message 
        await conn.sendMessage(from, { video: { url: downloadUrl }, mimetype: "video/mp4", caption: "*¬©·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è …¥…™ Ä·¥è-·¥ç·¥Ö*" }, { quoted: mek });
        await conn.sendMessage(from, { document: { url: downloadUrl }, mimetype: "video/mp4", fileName: deta.title + ".mp4", caption: "*¬©·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è …¥…™ Ä·¥è-·¥ç·¥Ö*" }, { quoted: mek });

    } catch (e) {
        console.log(e);
        reply(`${e}`);
    }
});



cmd({
    pattern: "happy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üòÇ",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üòÇ' });
        const emojiMessages = [
            "üòÉ", "üòÑ", "üòÅ", "üòä", "üòé", "ü•≥",
            "üò∏", "üòπ", "üåû", "üåà", "üòÉ", "üòÑ",
            "üòÅ", "üòä", "üòé", "ü•≥", "üò∏", "üòπ",
            "üåû", "üåà", "üòÉ", "üòÑ", "üòÅ", "üòä"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "heart",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "‚ù§Ô∏è",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üñ§' });
        const emojiMessages = [
            "üíñ", "üíó", "üíï", "ü©∑", "üíõ", "üíö",
            "ü©µ", "üíô", "üíú", "üñ§", "ü©∂", "ü§ç",
            "ü§é", "‚ù§Ô∏è‚Äçüî•", "üíû", "üíì", "üíò", "üíù",
            "‚ô•Ô∏è", "üíü", "‚ù§Ô∏è‚Äçü©π", "‚ù§Ô∏è"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "angry",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ü§°",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üëΩ' });
        const emojiMessages = [
            "üò°", "üò†", "ü§¨", "üò§", "üòæ", "üò°",
            "üò†", "ü§¨", "üò§", "üòæ"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "sad",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üò∂",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üòî' });
        const emojiMessages = [
            "ü•∫", "üòü", "üòï", "üòñ", "üò´", "üôÅ",
            "üò©", "üò•", "üòì", "üò™", "üò¢", "üòî",
            "üòû", "üò≠", "üíî", "üò≠", "üòø"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "shy",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üßê",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üßê' });
        const emojiMessages = [
            "üò≥", "üòä", "üò∂", "üôà", "üôä",
            "üò≥", "üòä", "üò∂", "üôà", "üôä"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "moon",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üåö",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üåù' });
        const emojiMessages = [
            "üåó", "üåò", "üåë", "üåí", "üåì", "üåî",
            "üåï", "üåñ", "üåó", "üåò", "üåë", "üåí",
            "üåì", "üåî", "üåï", "üåñ", "üåó", "üåò",
            "üåë", "üåí", "üåì", "üåî", "üåï", "üåñ",
            "üåó", "üåò", "üåë", "üåí", "üåì", "üåî",
            "üåï", "üåñ", "üåùüåö"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "confused",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "ü§î",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'ü§î' });
        const emojiMessages = [
            "üòï", "üòü", "üòµ", "ü§î", "üòñ", 
            "üò≤", "üò¶", "ü§∑", "ü§∑‚Äç‚ôÇÔ∏è", "ü§∑‚Äç‚ôÄÔ∏è"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "hot",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üíã",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'üíã' });
        const emojiMessages = [
            "ü•µ", "‚ù§Ô∏è", "üíã", "üò´", "ü§§", 
            "üòã", "ü•µ", "ü•∂", "üôä", "üòª", 
            "üôà", "üíã", "ü´Ç", "ü´Ä", "üëÖ", 
            "üëÑ", "üíã"
        ];

        for (const line of emojiMessages) {
            await new Promise(resolve => setTimeout(resolve, 1000)); // Delay for 1 second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: line,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

cmd({
    pattern: "nikal",
    desc: "Displays a dynamic edit msg for fun.",
    category: "tools",
    react: "üóø",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const loadingMessage = await conn.sendMessage(from, { text: 'MINUKI-MDüóø' });
        
        // Define the ASCII art messages
        const asciiMessages = [
            "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä     ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä  ‚†Ä    ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤     ‚£ø  ‚£∏   Nikal   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä      ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä‚†Ä__‚†Ä   ‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä  ‚†Ä  ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä       ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤     ‚£ø  ‚£∏   Lavde   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä      ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä|__|‚†Ä‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä     ‚†Ä   ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä      ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏   Pehli   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä     ‚£ø  ‚¢π‚†Ä           ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä(P)‚†Ä‚†Ä     ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä     ‚†Ä   ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä   ‚†Ä     ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏  Fursat  ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä        ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä‚†Ä__ ‚†Ä  ‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä      ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä ‚†Ä      ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏  Meeee   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä       ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä|__| ‚†Ä    ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚†Ä‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä       ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä  ‚†Ä       ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤   ‚£ø  ‚£∏   Nikal   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä       ‚£ø  ‚¢π‚†Ä           ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Älodu‚†Ä‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä   ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä  ‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä"
        ];

        // Send the initial loading message
        for (const asciiMessage of asciiMessages) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Delay for 500ms second
            await conn.relayMessage(
                from,
                {
                    protocolMessage: {
                        key: loadingMessage.key,
                        type: 14,
                        editedMessage: {
                            conversation: asciiMessage,
                        },
                    },
                },
                {}
            );
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});

// > adhi ofc





cmd({
    pattern: "bugdr1",
    desc: "Check if the bot is alive.",
    category: "main",
    react: "‚úÖ",
    filename: __filename
}, async (conn, mek, m, { from, quoted, reply }) => {
    try {
        // Send a message indicating the bot is alive
        await conn.sendMessage(from, { text: '*‚óÜ‚îÄ„Äà ‚ú¶ùêÉùê¢ùêùùêÆùê•ùêö ùêåùêÉ ùêïùüê‚ú¶ „Äâ‚îÄ‚óÜ*' });

        // Simulate some processing time
        const startTime = Date.now();
        await new Promise(resolve => setTimeout(resolve, 500)); // Simulating a delay
        const endTime = Date.now();
        const ping = endTime - startTime; // Capture the ping time

        // Send the alive response with additional information
        await conn.sendMessage(from, {
            document: { url: pdfUrl }, // Ensure pdfUrl is defined
            fileName: '„Äà ‚ú¶ùêÉùê¢ùêùùêÆùê•ùêö ùêåùêÉ ùêïùüê‚ú¶ „Äâ', // Filename for the document
            mimetype: "application/pdf",
            fileLength: 99999999999999, // Adjust file length as necessary
            image: { url: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg' },
            pageCount: 2024,
            caption: "`UI Youko`\n>  ÕÜ Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫“â Ã∫\n" + "‡´Ä".repeat(505),
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterName: '„Äà ‚ú¶ùêÉùê¢ùêùùêÆùê•ùêö ùêåùêÉ ùêïùüê‚ú¶ „Äâ',
                    newsletterJid: "120363343196447945@newsletter",
                },
                externalAdReply: {
                    title: '¬©„Äà ‚ú¶ùêÉùê¢ùêùùêÆùê•ùêö ùêåùêÉ ùêïùüê‚ú¶ „Äâ',
                    body: ' *„Äà ‚ú¶ùêÉùê¢ùêùùêÆùê•ùêö ùêåùêÉ ùêïùüê‚ú¶ „Äâ*',
                    thumbnailUrl: 'https://i.ibb.co/tC37Q7B/20241220-122443.jpg',
                    sourceUrl: 'https://wa.me/message/DIDULLTK7ZOGH1',
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        });

    } catch (e) {
        console.error(e); // Log the error for debugging
        reply(`An error occurred: ${e.message || e}`); // Provide a user-friendly error message
    }
});
